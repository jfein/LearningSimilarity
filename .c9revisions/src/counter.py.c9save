{"ts":1354038189778,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n"]],"start1":0,"start2":0,"length1":0,"length2":1}]],"length":1}
{"contributors":["jeremy.d.fein@gmail.com"],"silentsave":false,"ts":1354038196518,"patch":[[{"diffs":[[1,"## {{{ http://code.activestate.com/recipes/576611/ (r11)\nfrom operator import itemgetter\nfrom heapq import nlargest\nfrom itertools import repeat, ifilter\n\nclass Counter(dict):\n    '''Dict subclass for counting hashable objects.  Sometimes called a bag\n    or multiset.  Elements are stored as dictionary keys and their counts\n    are stored as dictionary values.\n\n    >>> Counter('zyzygy')\n    Counter({'y': 3, 'z': 2, 'g': 1})\n\n    '''\n\n    def __init__(self, iterable=None, **kwds):\n        '''Create a new, empty Counter object.  And if given, count elements\n        from an input iterable.  Or, initialize the count from another mapping\n        of elements to their counts.\n\n        >>> c = Counter()                           # a new, empty counter\n        >>> c = Counter('gallahad')                 # a new counter from an iterable\n        >>> c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping\n        >>> c = Counter(a=4, b=2)                   # a new counter from keyword args\n\n        '''        \n        self.update(iterable, **kwds)\n\n    def __missing__(self, key):\n        return 0\n\n    def most_common(self, n=None):\n        '''List the n most common elements and their counts from the most\n        common to the least.  If n is None, then list all element counts.\n\n        >>> Counter('abracadabra').most_common(3)\n        [('a', 5), ('r', 2), ('b', 2)]\n\n        '''        \n        if n is None:\n            return sorted(self.iteritems(), key=itemgetter(1), reverse=True)\n        return nlargest(n, self.iteritems(), key=itemgetter(1))\n\n    def elements(self):\n        '''Iterator over elements repeating each as many times as its count.\n\n        >>> c = Counter('ABCABC')\n        >>> sorted(c.elements())\n        ['A', 'A', 'B', 'B', 'C', 'C']\n\n        If an element's count has been set to zero or is a negative number,\n        elements() will ignore it.\n\n        '''\n        for elem, count in self.iteritems():\n            for _ in repeat(None, count):\n                yield elem\n\n    # Override dict methods where the meaning changes for Counter objects.\n\n    @classmethod\n    def fromkeys(cls, iterable, v=None):\n        raise NotImplementedError(\n            'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')\n\n    def update(self, iterable=None, **kwds):\n        '''Like dict.update() but add counts instead of replacing them.\n\n        Source can be an iterable, a dictionary, or another Counter instance.\n\n        >>> c = Counter('which')\n        >>> c.update('witch')           # add elements from another iterable\n        >>> d = Counter('watch')\n        >>> c.update(d)                 # add elements from another counter\n        >>> c['h']                      # four 'h' in which, witch, and watch\n        4\n\n        '''        \n        if iterable is not None:\n            if hasattr(iterable, 'iteritems'):\n                if self:\n                    self_get = self.get\n                    for elem, count in iterable.iteritems():\n                        self[elem] = self_get(elem, 0) + count\n                else:\n                    dict.update(self, iterable) # fast path when counter is empty\n            else:\n                self_get = self.get\n                for elem in iterable:\n                    self[elem] = self_get(elem, 0) + 1\n        if kwds:\n            self.update(kwds)\n\n    def copy(self):\n        'Like dict.copy() but returns a Counter instance instead of a dict.'\n        return Counter(self)\n\n    def __delitem__(self, elem):\n        'Like dict.__delitem__() but does not raise KeyError for missing values.'\n        if elem in self:\n            dict.__delitem__(self, elem)\n\n    def __repr__(self):\n        if not self:\n            return '%s()' % self.__class__.__name__\n        items = ', '.join(map('%r: %r'.__mod__, self.most_common()))\n        return '%s({%s})' % (self.__class__.__name__, items)\n\n    # Multiset-style mathematical operations discussed in:\n    #       Knuth TAOCP Volume II section 4.6.3 exercise 19\n    #       and at http://en.wikipedia.org/wiki/Multiset\n    #\n    # Outputs guaranteed to only include positive counts.\n    #\n    # To strip negative and zero counts, add-in an empty counter:\n    #       c += Counter()\n\n    def __add__(self, other):\n        '''Add counts from two counters.\n\n        >>> Counter('abbb') + Counter('bcc')\n        Counter({'b': 4, 'c': 2, 'a': 1})\n\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        result = Counter()\n        for elem in set(self) | set(other):\n            newcount = self[elem] + other[elem]\n            if newcount > 0:\n                result[elem] = newcount\n        return result\n\n    def __sub__(self, other):\n        ''' Subtract count, but keep only results with positive counts.\n\n        >>> Counter('abbbc') - Counter('bccd')\n        Counter({'b': 2, 'a': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        result = Counter()\n        for elem in set(self) | set(other):\n            newcount = self[elem] - other[elem]\n            if newcount > 0:\n                result[elem] = newcount\n        return result\n\n    def __or__(self, other):\n        '''Union is the maximum of value in either of the input counters.\n\n        >>> Counter('abbb') | Counter('bcc')\n        Counter({'b': 3, 'c': 2, 'a': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        _max = max\n        result = Counter()\n        for elem in set(self) | set(other):\n            newcount = _max(self[elem], other[elem])\n            if newcount > 0:\n                result[elem] = newcount\n        return result\n\n    def __and__(self, other):\n        ''' Intersection is the minimum of corresponding counts.\n\n        >>> Counter('abbb') & Counter('bcc')\n        Counter({'b': 1})\n\n        '''\n        if not isinstance(other, Counter):\n            return NotImplemented\n        _min = min\n        result = Counter()\n        if len(self) < len(other):\n            self, other = other, self\n        for elem in ifilter(self.__contains__, other):\n            newcount = _min(self[elem], other[elem])\n            if newcount > 0:\n                result[elem] = newcount\n        return result\n\n\nif __name__ == '__main__':\n    import doctest\n    print doctest.testmod()\n## end of http://code.activestate.com/recipes/576611/ }}}\n"],[0,"\n"]],"start1":0,"start2":0,"length1":1,"length2":6416}]],"length":6416,"saved":false}
